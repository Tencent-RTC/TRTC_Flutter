import 'dart:io';
import 'package:flutter/foundation.dart';
import 'package:flutter/gestures.dart';
import 'package:flutter/material.dart';
import 'package:flutter/rendering.dart';
import 'package:flutter/services.dart';
import 'package:tencent_trtc_cloud/core/key_metrics_stats.dart';
import 'package:tencent_trtc_cloud/core/store.dart';
import 'trtc_cloud_def.dart';
import 'package:tencent_trtc_cloud/core/event_center.dart';

/// @nodoc
/// MethodChannel identifier
String channelType = TRTCCloudDef.TRTC_VideoView_TextureView;

/// @nodoc
/// Flutter Android support two integration modesï¼šVirtual displays and Hybrid composition.
String viewMode = TRTCCloudDef.TRTC_VideoView_Model_Virtual;

/// Video view window, which displays the local video, remote video, or substream
///
/// **Parameters:**
///
/// `onViewCreated`: `viewId` generated by callback for view creation
///
/// `key`: Widget key, which can be left empty
///
/// `viewType`: this parameter takes effect only for Android and can be left empty
///
/// The type of view component used for Android video rendering. There are two components to choose from: `SurfaceView` and `TextureView` (default value)
///
/// If you want to use `TextureView` for rendering, pass in [TRTCCloudDef.TRTC_VideoView_TextureView] for `viewType`
///
/// If you want to use `SurfaceView` for rendering, pass in [TRTCCloudDef.TRTC_VideoView_SurfaceView] for `viewType`
class TRTCCloudVideoView extends StatefulWidget {

  /// The callback after the view has been created will return a `viewId` which is used to uniquely identify a platform view in Flutter.
  final ValueChanged<int>? onViewCreated;

  /// Specifies how the platform view is rendered, valid only for Android, can be null
  final String? viewType;

  /// Specify the mode of video rendering, only available for Android, can be null.
  final String? viewMode;

  /// Customized rendering parameters that can be specified locally or remotely
  final CustomRender? textureParam;

  /// Gesture recognizer to handle gesture events for the view
  final Set<Factory<OneSequenceGestureRecognizer>>? gestureRecognizers;

  /// [PlatformViewHitTestBehavior] Enumeration value that specifies how the click test is performed. Click tests are used to determine if the location of the user's click or touch is within the view.
  final PlatformViewHitTestBehavior? hitTestBehavior;
  const TRTCCloudVideoView(
      {Key? key,
      this.viewType,
      this.viewMode,
      this.textureParam,
      this.onViewCreated,
      this.hitTestBehavior,
      this.gestureRecognizers})
      : super(key: key);

  @override
  State<StatefulWidget> createState() =>
      TRTCCloudVideoViewState(this.viewType, this.viewMode, this.textureParam);
}

//// @nodoc
class TRTCCloudVideoViewState extends State<TRTCCloudVideoView> {
  int? _textureId;
  CustomRender? _textureParam;
  int textureVideoWidth = 720;
  int textureVideoHeight = 1280;
  TRTCRenderParams _textureRenderParams = TRTCRenderParams();

  late EventCenterCallback updateTextureRenderCallback = (arg){
    if (widget.viewType != TRTCCloudDef.TRTC_VideoView_Texture) { return; }
    TRTCRenderParams params;
    if (_textureParam!.isLocal) {
      params = Store.sharedInstance().localTextureParam;
    } else {
      String userId = Store.sharedInstance().textureUserIdMap[_textureId!]!;
      params = Store.sharedInstance().userRenderParamsMap[userId]!;
    }

    if (mounted) {
      setState(() {
        _textureRenderParams = params;
      });
    }
  };

  late EventCenterCallback onEnterRoomCallback = (arg){
    setKeyMetricsStats(widget.viewType == TRTCCloudDef.TRTC_VideoView_Texture ?
    KeyMetricsStats_TextureRender : KeyMetricsStats_PlatformViewRender);
  };

  TRTCCloudVideoViewState(
      String? viewType, String? mode, CustomRender? textureParam) {
    _textureParam = textureParam;
    if (viewType != null) {
      channelType = viewType;
    }
    if (mode != null) {
      viewMode = mode;
    }
    if (kIsWeb ||
        (Platform.isIOS &&
            viewType == TRTCCloudDef.TRTC_VideoView_SurfaceView)) {
      // iOS not support TRTC_VideoView_SurfaceView
      channelType = TRTCCloudDef.TRTC_VideoView_TextureView;
    }
    if (!kIsWeb && (Platform.isWindows || Platform.isMacOS)) {
      // MAC / Windows only supports texture rendering
      channelType = TRTCCloudDef.TRTC_VideoView_Texture;
    }
    EventCenter().register(updateTextureRenderEvent, updateTextureRenderCallback);
    EventCenter().register(onEnterRoomEvent, onEnterRoomCallback);
  }

  @override
  void didUpdateWidget(TRTCCloudVideoView oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (widget.textureParam != null && Platform.isAndroid) {
      if (widget.textureParam!.width != oldWidget.textureParam!.width ||
          widget.textureParam!.height != oldWidget.textureParam!.height) {
        if (widget.textureParam!.isLocal) {
          ////Update the width and height when the width and height change. In order to ensure no deformation, there may be black edges. If you don't want black edges, you can call `setVideoEncoderParam` to set the resolution close to the width and height
          MethodChannel('trtcCloudChannel').invokeMethod(
              'updateLocalVideoRender', {
            "width": widget.textureParam!.width,
            "height": widget.textureParam!.height
          });
        } else {
          MethodChannel('trtcCloudChannel')
              .invokeMethod('updateRemoteVideoRender', {
            "textureID": _textureId,
            "width": widget.textureParam!.width,
            "height": widget.textureParam!.height
          });
        }
      }
    }
  }

  @override
  void initState() {
    super.initState();
    if (channelType == TRTCCloudDef.TRTC_VideoView_Texture &&
        _textureParam != null) {
      if (_textureParam!.isLocal) {
        MethodChannel('trtcCloudChannel')
            .invokeMethod('setLocalVideoRenderListener', {
          "userId": _textureParam!.userId,
          "isFront":
              _textureParam!.isFront == null ? true : _textureParam!.isFront,
          "streamType": _textureParam!.streamType,
          "width": _textureParam!.width,
          "height": _textureParam!.height
        }).then((value) => {
                  setState(() {
                    _textureId = value;
                    MethodChannel('trtcCloudChannel_texture_$_textureId').setMethodCallHandler(textureMethodCallHandler);
                  })
                });
      } else {
        MethodChannel('trtcCloudChannel')
            .invokeMethod('setRemoteVideoRenderListener', {
          "userId": _textureParam!.userId,
          "streamType": _textureParam!.streamType,
          "width": _textureParam!.width,
          "height": _textureParam!.height
        }).then((value) => {
                  setState(() {
                    _textureId = value;
                    Store.sharedInstance().setTextureUserIdMap(_textureId!, _textureParam!.userId);
                    MethodChannel('trtcCloudChannel_texture_$_textureId').setMethodCallHandler(textureMethodCallHandler);
                  })
                });
      }
      return;
    }
  }
  
  Future<dynamic> textureMethodCallHandler(MethodCall call) {
    switch (call.method) {
      case 'updateTextureVideoResolution':
        textureVideoWidth = call.arguments["width"];
        textureVideoHeight = call.arguments["height"];
        break;
      default:
        throw MissingPluginException();
    }
    setState(() {});
    return Future.value(1);
  }

  @override
  void dispose() {
    super.dispose();
    if (channelType == TRTCCloudDef.TRTC_VideoView_Texture &&
        _textureId != null) {
      MethodChannel('trtcCloudChannel')
          .invokeMethod('unregisterTexture', {"textureID": _textureId});
    }
  }

  Widget _buildIOSTexture() {
    double aspectRatio = textureVideoWidth / textureVideoHeight;
    Widget texture = Center(
        child:AspectRatio(
            aspectRatio: aspectRatio,
            child: Texture(textureId: _textureId!)
        )
    );

    return _applyTextureRenderFillMode(_textureRenderParams.fillMode, texture);;
  }


  Widget _applyTextureRenderFillMode(int fillMode, Widget child) {
    if (fillMode == TRTCCloudDef.TRTC_VIDEO_RENDER_MODE_FIT) {
      return Container(
        color: Colors.black,
        constraints: const BoxConstraints.expand(),
        child: FittedBox(
          fit: BoxFit.contain,
          child: SizedBox(
            width: textureVideoWidth.toDouble(),
            height: textureVideoHeight.toDouble(),
            child: child,
          ),
        ),
      );
    } else  {
      return Container(
        constraints: const BoxConstraints.expand(),
        child: FittedBox(
          fit: BoxFit.cover,
          child: SizedBox(
            width: textureVideoWidth.toDouble(),
            height: textureVideoHeight.toDouble(),
            child: child,
          ),
        ),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    if (channelType == TRTCCloudDef.TRTC_VideoView_Texture) {
      if (_textureId != null) {
        return Platform.isIOS ?  _buildIOSTexture() : Texture(textureId: _textureId!);
      }
      return Container();
    }
    if (kIsWeb) {
      return PlatformViewLink(
        viewType: channelType,
        surfaceFactory:
            (BuildContext context, PlatformViewController controller) {
          return PlatformViewSurface(
            controller: controller,
            hitTestBehavior: PlatformViewHitTestBehavior.transparent,
            gestureRecognizers: widget.gestureRecognizers != null
                ? widget.gestureRecognizers!
                : const <Factory<OneSequenceGestureRecognizer>>{},
          );
        },
        onCreatePlatformView: (PlatformViewCreationParams params) {
          final controller =
              _HtmlElementViewController(params.id, params.viewType);
          controller._initialize().then((_) {
            params.onPlatformViewCreated(params.id);
            _onPlatformViewCreated(params.id);
          });
          return controller;
        },
      );
    } else if (Platform.isAndroid) {
      if (viewMode == TRTCCloudDef.TRTC_VideoView_Model_Virtual) {
        return AndroidView(
          hitTestBehavior: widget.hitTestBehavior == null ? PlatformViewHitTestBehavior.opaque : widget.hitTestBehavior!,
          viewType: channelType,
          onPlatformViewCreated: _onPlatformViewCreated,
          gestureRecognizers: widget.gestureRecognizers,
        );
      } else {
        return PlatformViewLink(
          viewType: channelType,
          surfaceFactory:
              (BuildContext context, PlatformViewController controller) {
            return PlatformViewSurface(
              controller: controller as AndroidViewController,
              hitTestBehavior: PlatformViewHitTestBehavior.transparent,
              gestureRecognizers: widget.gestureRecognizers != null
                  ? widget.gestureRecognizers!
                  : const <Factory<OneSequenceGestureRecognizer>>{},
            );
          },
          onCreatePlatformView: (PlatformViewCreationParams params) {
            return PlatformViewsService.initSurfaceAndroidView(
              id: params.id,
              viewType: channelType,
              layoutDirection: TextDirection.ltr,
              creationParamsCodec: StandardMessageCodec(),
            )
              ..addOnPlatformViewCreatedListener((id) {
                params.onPlatformViewCreated(id);
                _onPlatformViewCreated(id);
              })
              ..create();
          },
        );
      }
    } else if (Platform.isIOS) {
      return UiKitView(
        hitTestBehavior: widget.hitTestBehavior == null ? PlatformViewHitTestBehavior.opaque : widget.hitTestBehavior!,
        viewType: channelType,
        onPlatformViewCreated: _onPlatformViewCreated,
        gestureRecognizers: widget.gestureRecognizers,
      );
    } else {
      return Center(
        child: Text(
          "This platform does not support `Platform View`",
          style: TextStyle(color: Colors.red, fontWeight: FontWeight.bold),
        ),
      );
    }
  }

  void _onPlatformViewCreated(int id) {
    widget.onViewCreated!(id);
  }
}

/// @nodoc
class _HtmlElementViewController extends PlatformViewController
    with WidgetsBindingObserver {
  _HtmlElementViewController(
    this.viewId,
    this.viewType,
  );

  @override
  final int viewId;

  /// The unique identifier for the HTML view type to be embedded by this widget.
  ///
  /// A PlatformViewFactory for this type must have been registered.
  final String viewType;

  bool _initialized = false;

  Future<void> _initialize() async {
    final args = <String, dynamic>{
      'id': viewId,
      'viewType': viewType,
    };
    await SystemChannels.platform_views.invokeMethod<void>('create', args);
    _initialized = true;
  }

  @override
  Future<void> clearFocus() async {
    // Currently this does nothing on Flutter Web.
    // Implement this. See https://github.com/flutter/flutter/issues/39496
  }

  @override
  Future<void> dispatchPointerEvent(PointerEvent event) async {
    // We do not dispatch pointer events to HTML views because they may contain
    // cross-origin iframes, which only accept user-generated events.
  }

  @override
  Future<void> dispose() async {
    if (_initialized) {
      await SystemChannels.platform_views.invokeMethod<void>('dispose', viewId);
    }
  }
}

/// @nodoc
class TRTCCloudVideoViewController {
  TRTCCloudVideoViewController(int id)
      : _channel = new MethodChannel(channelType + '_$id');

  final MethodChannel _channel;

  /// Enable the preview image of local video
  ///
  /// When the first camera video frame starts to be rendered, you will receive the `onFirstVideoFrame(null)` callback in `TRTCCloudListener`.
  ///
  /// **Parameters:**
  ///
  /// frontCamera true: front camera; false: rear camera.
  Future<void> startLocalPreview(
    bool frontCamera, // true: front camera; false: rear camera.
    String channelName,
  ) {
    return _channel.invokeMethod('startLocalPreview', {
      "frontCamera": frontCamera,
      "channelName" : channelName,
    });
  }

  /// Update the preview image of local video
  ///
  /// **Parameters:**
  ///
  /// viewId Control that carries the video image
  Future<void> updateLocalView(int viewId, String channelName) {
    return _channel.invokeMethod('updateLocalView', {
      "viewId": viewId,
      "channelName" : channelName,
    });
  }

  /// Update the window of remote video image
  ///
  /// **Parameters:**
  ///
  /// userId  `userId` of the specified remote user
  ///
  /// streamType: video stream type of the `userId` specified for watching
  ///
  /// viewId Control that carries the video image
  Future<void> updateRemoteView(String userId, int streamType, int viewId, String channelName) {
    return _channel.invokeMethod('updateRemoteView', {
      "viewId": viewId,
      "streamType": streamType,
      "userId": userId,
      "channelName" : channelName,
    },
    );
  }

  /// Display remote video image or substream
  ///
  /// **Parameters:**
  ///
  /// userId   `userId` of the specified remote user
  ///
  /// streamType: video stream type of the `userId` specified for watching:
  ///
  ///* HD big image:TRTCCloudDef.TRTC_VIDEO_STREAM_TYPE_BIG
  ///
  ///* Smooth big image:TRTCCloudDef.TRTC_VIDEO_STREAM_TYPE_SMALL
  ///
  ///* Substream (screen sharing): TRTCCloudDe.TRTC_VIDEO_STREAM_TYPE_SUB
  Future<void> startRemoteView(String userId, int streamType, String channelName) {
    return _channel.invokeMethod('startRemoteView', {
      "userId": userId,
      "streamType": streamType,
      "channelName" : channelName,
    });
  }
}
